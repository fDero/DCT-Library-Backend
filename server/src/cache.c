
#include <hiredis/hiredis.h>
#include "cache.h"
#include "assert.h"
#include "utils.h"
#include <stdbool.h>
#include "hash.h"
#include <pthread.h>

pthread_key_t cache_connection_key;

int redis_port = 0;
char* redis_host = NULL;

void cache_connection_init(){
    redis_port = atoi(getenv("REDISPORT"));
    char *redis_host_str = getenv("REDISHOST");
    redis_host = (char*)malloc(strlen(redis_host_str) + 1);
    strcpy(redis_host, redis_host_str);
    pthread_key_create(&cache_connection_key, close_cache_connection_callback);
}

cache_conn_t* open_cache_connection(){
    return redisConnect(redis_host, redis_port);
}

void close_cache_connection(cache_conn_t* conn){
    redisFree(conn);
}

void close_cache_connection_callback(void* conn){
    close_cache_connection((cache_conn_t*)conn);
}

char* get_value_by_key_from_cache(cache_conn_t* conn, const char* key){
    redisReply* reply = (redisReply*)redisCommand(conn,"GET %s", key);
    if (reply == NULL || reply->type != REDIS_REPLY_STRING){
        freeReplyObject(reply);
        return NULL;
    }
    char* value;
    alloc_and_strcpy(&value, reply->str);
    freeReplyObject(reply);
    return value;
}

bool insert_key_value_pair_into_cache(cache_conn_t* conn, const char* key, const char* val, unsigned long expiration_time){
    redisReply* reply = (redisReply*)redisCommand(conn,"SETNX %s %s", key, val);
    bool outcome = (reply != NULL && reply->type == REDIS_REPLY_INTEGER);
    outcome &= (reply->integer == 1);
    freeReplyObject(reply);
    if (outcome){
        reply = (redisReply*)redisCommand(conn,"EXPIRE %s %d", key, expiration_time);
        outcome &= (reply != NULL && reply->type == REDIS_REPLY_INTEGER);
        outcome &= (reply->integer == 1);
        freeReplyObject(reply);
    }
    return outcome;
}

char* generate_random_key(cache_conn_t* conn){
    redisReply* reply = (redisReply*)redisCommand(conn,"INCR keycounter");
    assert(reply != NULL);
    assert(reply->type == REDIS_REPLY_INTEGER);
    long long int keynum = reply->integer;
    freeReplyObject(reply);
    return sha256_hash_number(keynum);
}

char* insert_value_with_autogenerated_unique_key(cache_conn_t* conn, const char* value, unsigned long expiration_time){
    for (int i = 0; i < 120; i++){
        char* key = generate_random_key(conn);
        if (insert_key_value_pair_into_cache(conn, key, value, expiration_time)){
            return key;
        }
        free(key);
    }
    return NULL;
}